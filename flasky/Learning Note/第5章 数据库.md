# 第5章 数据库
- Web应用最常使用基于关系模型的数据库，即SQL数据库，因为他们使用结构化查询语言（SQL）
- 文档数据库和键-值对数据库合称NoSQL数据库

## 5.1 SQL数据库
- 关系型数据库把数据存储在表中，表为应用中不同的实体建模
- 列定义表所表示的实体的数据属性
- 行定义部分或所有列对应的真实数据

- 表中有个特殊的列，称为主键，其值为表中各行的唯一标识符
- 表中还可以有称为外键的列，引用同一个表或不同表中某一行的主键
- 行之间的这种联系称为关系，这正是关系型数据库模型的基础

- 关系型数据库存储数据很高效，而且避免了重复

## 5.2 NoSQL数据库
- NoSQL数据库一般使用集合代替表，使用文档代替记录
- NoSQL数据库的设计减少了表的数量，却增加了数据重复量

## 5.3 使用SQL还是NoSQL
- SQL数据库擅于用高效且紧凑的形式存储结构化数据
- 关系型数据库采用一种称为ACID的范式：
    - atomicity:原子性
    - consistency:一致性
    - isolation:隔离性
    - durability:持续性
    
## 5.4 Python数据库框架
- ORM:对象关系映射器
- ODM:对象文档映射器

## 5.5 使用Flask-SQLAlchemy管理数据库
- Flask-SQLAlchemy是一个Flask扩展，简化了Flask应用中使用SQLAlchemy的操作
- SQLAlchemy是一个强大的关系型数据库框架，支持多种数据库后台
- SQLAlchemy提高了高层ORM,也提供了使用数据库原生SQL的低层功能

- 安装：pip install flask-sqlalchemy

- 在Flask-SQLAlchemy中，数据库使用URL指定


    # MySQL使用格式：
    mysql+pymysql:username:password@hostname/database
    
- 应用使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中
- Flask-SQLAlchemy文档还建议把SQLALCHEMY_TRACK_MODIFICATIONS键设为Flase,以便在不需要跟踪对象变化时降低内存消耗

- 示例初始化及配置一个简单的MySQL数据库：


    from flask_sqlalchemy import SQLAlchemy
    
    app = Flask(__name__)
    
    # 配置MySQL数据库
    app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:123456@localhost/flask?charset=utf8mb4'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
    # 创建SQLAlchemy类的实例，为模型提供一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构
    db = SQLAlchemy(app)
    
- db对象是SQLAlchemy类的实例，表示应用使用的数据库，通过它可以获得Flask-SQLAlchemy提供的所有功能

## 5.6 定义模型
- 模型这个术语表示应用的持久化实体
- 在ORM中，模型一般是一个Python类，类中的属性对象对应于数据库表中的列

- Flask-SQLAlchemy创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构


    # 定义Role和User模型
    class Role(db.Model):
        __tablename__ = 'roles'
        id = db.Column(db.Integer,primary_key=True)
        name = db.Column(db.String(64),unique=True)
        
        def __repr__(self):
            return '<Role %r>' % self.name
            
    class User(db.Model):
        __tablename__ = 'users'
        id = db.Column(db.Integer,primary_key=True)
        username = db.Column(db.String(64),unique=True,index=True)
        
        def __repr__(self):
            return '<User %r>' % self.username

- 类变量__tablename__定义在数据库中使用的表名
- 其余的类变量都是该模型的属性，定义为db.Column类的实例
- db.Column类构造函数的第一个参数是数据库列和模型属性的类型
- db.Column的其余参数指定属性的配置选项

## 5.7 关系
- 关系型数据库使用关系把不同表中的行联系起来

- 示例一对多关系在模型类中的表示方法：


    class Role(db.Model):
        # ...
        users = db.relationship('User',backref='role')
    
    class User(db.Model):
        # ...
        role_id = db.Column(db.Integer,db.ForeignKey('roles.id'))
        
- db.relationship()的第一个参数表明这个关系的另一端是哪个模型
- db.relationship()中的backref参数向User模型中添加一个role属性，从而定义反向关系，通过User实例的这个属性可以获取对应的Role模型对象，而不用再通过role_id外键获取

- 一对一关系在调用db.relationship()时要把uselist设为False,把多变为一

## 5.8 数据库操作

### 5.8.1 创建表
- 首先，要让Flask-SQLAlchemy根据模型类创建数据库
- db.create_all()函数将寻找所有db.Model的子类，然后在数据库中创建对应的表


    flask shell
    
    from hello import db
    
    db.create_all()
    
### 5.8.2 插入行
- 示例代码创建一些角色和用户


    from hello import Role,User
    
    admin_role = Role(name='Admin')
    
    mod_role = Role(name='Moderator')
    
    user_role = Role(name='User')
    
    user_john = User(username='john',role=admin_role)
    
    user_susan = User(username='susan',role=user_role)
    
    user_david = User(username='david',role=user_role)

- 模型的构造函数接受的参数是关键字参数指定的模型属性初始值
- User模型中的role属性也可以使用，即使它不是真正的数据库列，但却是一对多关系的高级表示

- 对数据库的改动通过数据库会话管理，在Flask-SQLAlchemy中，会话由db.session表示
- 准备把对象写入数据库之前，要先将其添加到会话中：


    db.session.add(admin_role)
    ...
    
    # 或者简写为：
    db.session.add_all([admin_role,mod_role,user_role,user_john,user_susan,user_david])
    
- 为了把对象写入数据库，要调用commit()方法提交会话：


    db.session.commit()
    
- 数据库会话也称为事务
- 数据库会话能保证数据库的一致性
- 提交操作使用原子方式把会话中的对象全部写入数据库

- 数据库会话也可以回滚，调用db.session.rollback()后，添加到数据库会话中的所有对象都将还原到他们在数据库中的状态

### 5.8.3 修改行
- 在数据库会话上调用add()方法也能更新模型


    # 将'Admin'角色重命名为'Administrator'
    admin_role.name = 'Administrator'
    
    db.session.add(admin_role)
    
    db.session.commit()

### 5.8.4 删除行
- Flask-SQLAlchemy为每个模型类都提供了query对象
- 最基本的模型查询是使用all()方法取回对应表中的所有记录：


    Role.query.all()
    
    User.query.all()

- 使用过滤器可以配置query对象进行更精确的数据库查询
- 示例查找角色为'User'的所有用户：


    User.query.filter_by(role=user_role).all()

- 若想查看SQLAlchemy为查询生成的原生SQL查询语句，只需把query对象转换成字符串：


    str(User.query.filter_by(role=user_role))

- 加载名为'User'的用户角色：


    user_role = Role.query.filter_by(name='User').first()
    
- all()方法返回所有结果构成的列表
- first()方法只返回第一个结果，如果没有结果，则返回None

- filter_by()等过滤器在query对象上调用，返回一个更精确的query对象
- 多个过滤器可以一起调用，直到获得所需结果

- 关系与查询的处理方式类似
- 示例分别从关系的两端查询角色和用户之间的一对多关系：


    users = user_role.users
    
    users
    
    users[0].role

- 修改关系的设置为lazy='dynamic'，从而禁止自动执行查询


    # 动态数据库关系
    class Role(db.Model):
        # ...
        users = db.relationship('User',backref='role',lazy='dynamic')
        # ...

- 这样配置关系之后，user_role.users将返回一个尚未执行的查询，因此可以在其上添加过滤器：

    
    user_role.users.order_by(User.username).all()
    
    user_role.users.count()

## 5.9 在视图函数中操作数据库
- 示例把用户输入的名字记录到数据库中


    # hello.py:在视图函数中操作数据库
    @app.route('/',methods=['GET','POST'])
    def index():
        form = NameForm()
        if form.validate_on_submit():
            user = User.query.filter_by(username=form.name.data).first()
            if user is None:
                user = User(username=form.name.data)
                db.session.add(user)
                db.session.commit()
                session['known'] = False
            else:
                session['known'] = True
            session['name'] = form.name.data
            form.name.data = ''
            return redirect(url_for('index'))
        return render_template('index.html',form=form,name=session.get('name'),known=session.get('known',False))

- 上述代码对应的模板如下：


    # templates/index.html:在模板中定制欢迎消息
    {% extends "base.html" %}
    (% import "bootstrap/wtf.html" as wtf %)
    
    {% block title %}Flasky{% endblock %}
    
    {% block page_content %}
    <div class="page-header">
        <h1>Hello,{% if name %}{{ name }}{% else %}Stranger{% endif %}!</h1>
        {% if not known %}
        <p>Pleased to meet you!</p>
        {% else %}
        <p>Happy to see you again!</p>
        {% endif %}
    </div>
    {{ wtf.quick_form(form) }}
    {% endblock %}

## 5.10 集成Python shell
- 若想把对象添加到导入列表中，必须使用app.shell_context_processor装饰器创建并注册一个shell上下文处理器
- 示例：
    - 这个shell上下文处理器函数返回一个字典，包含数据库实例和模型
    - 除了默认导入的app之外，flask shell命令将自动把这些对象导入shell


    # hello.py:添加一个shell上下文
    @app.shell_context_processor
    def make_shell_context():
        return dict(db=db,User=User,Role=Role)

## 5.11 使用Flask-Migrate实现数据库迁移
- 更新表更好的方法是使用数据库迁移框架
- 源码版本控制工具可以跟踪源码文件的变化，类似地，数据库迁移框架能跟踪数据库模式的变化，然后以增量的方式把变化应用到数据库中

- SQLAlchemy的开发人员编写了一个迁移框架，名为Alembic

- 除了直接使用Alembic之外，Flask应用还可以使用Flask-Migrate扩展
- 这个扩展是对Alembic的轻量级包装，并于flask命令做了集成

### 5.11.1 创建迁移仓库
- 安装Flask-Migrate:pip install flask-migrate
- 示例该方法初始化


    # hello.py:初始化Flask-Migrate
    from flask_migrate import Migrate
    
    # ...
    
    migrate = Migrate(app,db)
    
- 为了开放数据库迁移相关命令，Flask-Migrate添加了flask db命令和几个子命令
- 在新项目中可以使用init子命令添加数据库迁移支持：
    - 这个命令会创建migrations目录，所有迁移脚本都存放在这里


    flask db init

### 5.11.2 创建迁移脚本
- Alembic中，数据库迁移用迁移脚本表示
- 脚本中有两个函数，upgrade(),downgrade()
- upgrade()函数把迁移中的改动应用到数据库中
- downgrade()函数则将改动删除
- Alembic具有添加和删除改动的能力，意味着数据库可重设到修改历史的任意一点

- 可以使用revision命令手动创建Alembic迁移；也可以使用migrate命令自动创建
- 手动创建的迁移只是一个骨架，upgrade()和downgrade()函数都是空的，开发者要使用Alembic提供的Operations对象指令实现具体操作
- 自动创建的迁移会根据模型定义和数据库当前状态之间的差异尝试生成upgrade()和downgrade()函数的内容

- 自动创建的迁移不一定总是正确的

- 使用Flask-Migrate管理数据库模式变化的步骤如下：
    - 1.对模型类做必要的修改
    - 2.执行flask db migrate 命令，自动创建一个迁移脚本
    - 3.检查自动生成的脚本，根据对模型的实际改动进行调整
    - 4.把迁移脚本纳入版本控制
    - 5.执行flask db upgrade 命令，把迁移应用到数据库中
    
- 示例，flask db migrate子命令用于自动创建迁移脚本：
    
    
    flask db migrate -m 'initial migration'

### 5.11.3 更新数据库
- 检查并修正好迁移脚本之后，执行flask db upgrade命令，把迁移应用到数据库中：


    falsk db upgrade

- 对第一个迁移来说，其作用与调用db.create_all()方法一样
- 但在后续迁移中，flask db upgrade命令能把改动应用到数据库中，且不影响其中保存的数据

- flask db stamp命令可以把现有数据库标记为已更新

### 5.11.4 添加几个迁移
- 修改数据库的步骤与创建第一个迁移类似：
    - 1.对数据库模型做必要的修改
    - 2.执行flask db migrate 命令，生成迁移脚本
    - 3.检查自动生成的脚本，改正不准确的地方
    - 4.执行flask db upgrade 命令，把改动应用到数据库中








